// Generated by CoffeeScript 1.10.0
(function() {
  var Compiler, ELSE_IF_REGEX, IF_REGEX, LOOP_REGEX, constantinople, doctypes, errorAtNode, filters, isConstant, jsExpressionToPhp, nodes, parseJSExpression, phpExtractorCode, phpRuntimeCode, runtime, selfClosing, toConstant, utils;

  isConstant = function(src) {
    return constantinople(src, {
      jade: runtime,
      jade_interp: undefined
    });
  };

  toConstant = function(src) {
    return constantinople.toConstant(src, {
      jade: runtime,
      jade_interp: undefined
    });
  };

  errorAtNode = function(node, error) {
    error.line = node.line;
    error.filename = node.filename;
    return error;
  };

  jsExpressionToPhp = require('./jsExpressionToPhp');

  IF_REGEX = /^if\s\(\s?(.*)\)$/;

  ELSE_IF_REGEX = /^else\s+if\s+\(\s?(.*)\)$/;

  LOOP_REGEX = /^(for|while)\s*\((.+)\)$/;

  phpRuntimeCode = require('./phpRuntimeCode');

  phpExtractorCode = require('./phpExtractorCode');

  "use strict";

  nodes = require("jade/lib/nodes");

  filters = require("jade/lib/filters");

  doctypes = require("jade/lib/doctypes");

  runtime = require("jade/lib/runtime");

  utils = require("jade/lib/utils");

  selfClosing = require("void-elements");

  parseJSExpression = require("character-parser").parseMax;

  constantinople = require("constantinople");


  /**
  Initialize `Compiler` with the given `node`.
  
  @param {Node} node
  @param {Object} options
  @api public
   */

  Compiler = module.exports = Compiler = function(node, options) {
    this.options = options = options || {};
    this.node = node;
    this.hasCompiledDoctype = false;
    this.hasCompiledTag = false;
    this.pp = false;
    this.omitPhpRuntime = options.omitPhpRuntime || false;
    this.omitPhpExtractor = options.omitPhpExtractor || false;
    this.arraysOnly = typeof options.arraysOnly === 'boolean' ? options.arraysOnly : true;
    this.debug = false !== options.compileDebug;
    this.indents = 0;
    this.parentIndents = 0;
    this.terse = false;
    this.mixins = {};
    this.dynamicMixins = false;
    this.insideMixin = false;
    if (options.doctype) {
      this.setDoctype(options.doctype);
    }
  };


  /**
  Compiler prototype.
   */

  Compiler.prototype = {
    jsExpressionToPhp: function(s) {
      return jsExpressionToPhp(s, {
        arraysOnly: this.arraysOnly
      });
    },

    /**
    Compile parse tree to JavaScript.
    
    @api public
     */
    compile: function() {
      var e, error1, i, mixin, mixinNames, result, x, y;
      try {
        this.buf = [];
        if (this.pp) {
          this.buf.push("var jade_indent = [];");
        }
        this.lastBufferedIdx = -1;
        this.visit(this.node);
        if (!this.dynamicMixins) {
          mixinNames = Object.keys(this.mixins);
          i = 0;
          while (i < mixinNames.length) {
            mixin = this.mixins[mixinNames[i]];
            if (!mixin.used) {
              x = 0;
              while (x < mixin.instances.length) {
                y = mixin.instances[x].start;
                while (y < mixin.instances[x].end) {
                  this.buf[y] = "";
                  y++;
                }
                x++;
              }
            }
            i++;
          }
        }
        result = '';
        if (!this.omitPhpRuntime) {
          result += phpRuntimeCode;
        }
        if (!this.omitPhpExtractor) {
          result += phpExtractorCode;
        }
        result += this.buf.join(this.pp ? "\n" : "");
        return result;
      } catch (error1) {
        e = error1;
        console.error("Error transpiling Jade to PHP");
        throw e;
      }
    },

    /**
    Sets the default doctype `name`. Sets terse mode to `true` when
    html 5 is used, causing self-closing tags to end with ">" vs "/>",
    and boolean attributes are not mirrored.
    
    @param {string} name
    @api public
     */
    setDoctype: function(name) {
      this.doctype = doctypes[name.toLowerCase()] || "<!DOCTYPE " + name + ">";
      this.terse = this.doctype.toLowerCase() === "<!doctype html>";
      this.xml = 0 === this.doctype.indexOf("<?xml");
    },

    /**
    Buffer the given `str` exactly as is or with interpolation
    
    @param {String} str
    @param {Boolean} interpolate
    @api public
     */
    buffer: function(str, interpolate) {
      var code, match, range, rest, self;
      self = this;
      if (interpolate) {
        match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
        if (match) {
          this.buffer(str.substr(0, match.index), false);
          if (match[1]) {
            this.buffer(match[2] + "{", false);
            this.buffer(match[3], true);
            return;
          } else {
            rest = match[3];
            range = parseJSExpression(rest);
            if ("!" === match[2]) {
              code = "<?php echo " + (this.jsExpressionToPhp(range.src)) + " ?>";
            } else {
              code = "<?php echo htmlspecialchars(" + (this.jsExpressionToPhp(range.src)) + ") ?>";
            }
            this.bufferExpression(code);
            this.buffer(rest.substr(range.end + 1), true);
            return;
          }
        }
      }
      if (this.lastBufferedIdx === this.buf.length) {
        this.lastBufferedType = "text";
        this.lastBuffered += str;
        this.buf[this.lastBufferedIdx - 1] = this.bufferStartChar + this.lastBuffered;
      } else {
        this.buf.push(str);
        this.lastBufferedType = "text";
        this.bufferStartChar = "";
        this.lastBuffered = str;
        this.lastBufferedIdx = this.buf.length;
      }
    },

    /**
    Buffer the given `src` so it is evaluated at run time
    
    @param {String} src
    @api public
     */
    bufferExpression: function(src) {
      if (isConstant(src)) {
        return this.buffer(toConstant(src) + "", false);
      }
      if (this.lastBufferedIdx === this.buf.length) {
        this.lastBufferedType = "code";
        this.lastBuffered += src;
        this.buf[this.lastBufferedIdx - 1] = this.bufferStartChar + this.lastBuffered;
      } else {
        this.buf.push(src);
        this.lastBufferedType = "code";
        this.bufferStartChar = "";
        this.lastBuffered = "(" + src + ")";
        this.lastBufferedIdx = this.buf.length;
      }
    },

    /**
    Buffer an indent based on the current `indent`
    property and an additional `offset`.
    
    @param {Number} offset
    @param {Boolean} newline
    @api public
     */
    prettyIndent: function(offset, newline) {
      offset = offset || 0;
      newline = (newline ? "\n" : "");
      this.buffer(newline + Array(this.indents + offset).join("  "));
      if (this.parentIndents) {
        this.buf.push("buf.push.apply(buf, jade_indent);");
      }
    },

    /**
    Visit `node`.
    
    @param {Node} node
    @api public
     */
    visit: function(node) {
      var debug;
      debug = this.debug;
      this.visitNode(node);
    },

    /**
    Visit `node`.
    
    @param {Node} node
    @api public
     */
    visitNode: function(node) {
      return this["visit" + node.type](node);
    },

    /**
    Visit case `node`.
    
    @param {Literal} node
    @api public
     */
    visitCase: function(node) {
      var _;
      _ = this.withinCase;
      this.withinCase = true;
      this.buf.push("<?php switch (" + (this.jsExpressionToPhp(node.expr)) + ") : ?>");
      this.visit(node.block);
      this.buf.push("<?php endswitch ?>");
      this.withinCase = _;
    },

    /**
    Visit when `node`.
    
    @param {Literal} node
    @api public
     */
    visitWhen: function(node) {
      if ("default" === node.expr) {
        this.buf.push("<?php default : ?>");
      } else {
        this.buf.push("<?php case " + (this.jsExpressionToPhp(node.expr)) + " : ?>");
      }
      if (node.block) {
        this.visit(node.block);
        if ("default" !== node.expr) {
          this.buf.push("<?php break ?>");
        }
      }
    },

    /**
    Visit literal `node`.
    
    @param {Literal} node
    @api public
     */
    visitLiteral: function(node) {
      this.buffer(node.str);
    },

    /**
    Visit all nodes in `block`.
    
    @param {Block} block
    @api public
     */
    visitBlock: function(block) {
      var escape, i, j, len, pp;
      len = block.nodes.length;
      escape = this.escape;
      pp = this.pp;
      if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText) {
        this.prettyIndent(1, true);
      }
      i = 0;
      while (i < len) {
        if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i - 1].isText) {
          this.prettyIndent(1, false);
        }
        if (i < len - 1 && block.nodes[i].type === 'Code' && IF_REGEX.test(block.nodes[i].val)) {
          this.nextElses = [];
          j = i + 1;
          while (j < len && block.nodes[j].type === 'Code' && /^else/.test(block.nodes[j].val)) {
            this.nextElses.push(block.nodes[j]);
            ++j;
          }
          this.visit(block.nodes[i]);
          this.nextElses = null;
        } else {
          this.visit(block.nodes[i]);
        }
        if (block.nodes[i + 1] && block.nodes[i].isText && block.nodes[i + 1].isText) {
          this.buffer("\n");
        }
        ++i;
      }
    },

    /**
    Visit a mixin's `block` keyword.
    
    @param {MixinBlock} block
    @api public
     */
    visitMixinBlock: function(block) {
      this.buf.push("<?php if (is_callable($block)) $block(); ?>");
    },

    /**
    Visit `doctype`. Sets terse mode to `true` when html 5
    is used, causing self-closing tags to end with ">" vs "/>",
    and boolean attributes are not mirrored.
    
    @param {Doctype} doctype
    @api public
     */
    visitDoctype: function(doctype) {
      if (doctype && (doctype.val || !this.doctype)) {
        this.setDoctype(doctype.val || "default");
      }
      if (this.doctype) {
        if (/<\?/.test(this.doctype)) {
          this.buf.push("<?php echo \'" + (this.doctype.replace("'", "\'")) + "\' ?>");
        } else {
          this.buffer(this.doctype);
        }
      }
      this.hasCompiledDoctype = true;
    },

    /**
    Visit `mixin`, generating a function that
    may be called within the template.
    
    @param {Mixin} mixin
    @api public
     */
    visitMixin: function(mixin) {
      var args, attr, attrs, attrsBlocks, block, dynamic, k, key, l, len1, len2, mixinAttrs, mixin_end, mixin_start, oldInsideMixin, phpArg, phpArgs, phpMixinName, pp, preMergedAttrs, ref, rest, value;
      args = mixin.args || "";
      block = mixin.block;
      attrs = mixin.attrs;
      attrsBlocks = mixin.attributeBlocks;
      rest = void 0;
      if (args && /\.\.\.[a-zA-Z_][a-z_A-Z0-9]*\s*$/.test(args)) {
        args = args.split(',');
        rest = args.pop().trim().replace(/^\.\.\./, "");
        args = args.length > 0 ? args.join(',') : void 0;
      }
      phpArgs = args ? this.jsExpressionToPhp(args).replace(/;$/, '') : void 0;
      phpMixinName = mixin.name.replace(/-/g, '_');
      pp = this.pp;
      dynamic = mixin.name[0] === "#";
      key = mixin.name;
      if (dynamic) {
        this.dynamicMixins = true;
      }
      this.mixins[key] = this.mixins[key] || {
        used: false,
        instances: []
      };
      if (mixin.call) {
        this.mixins[key].used = true;
        this.buf.push("<?php mixin__" + phpMixinName + "(");
        if (block) {
          this.buf.push("function()");
          if (this.insideMixin) {
            this.buf.push(" use ($block) ");
          }
          this.buf.push("{ ?>");
          if (!this.omitPhpExtractor) {
            this.buf.push(phpExtractorCode);
          }
          this.visit(block);
          this.buf.push("<?php }");
        } else {
          if (phpArgs || attrs.length > 0) {
            this.buf.push("null");
          }
        }
        if (attrs.length > 0) {
          preMergedAttrs = {};
          for (k = 0, len1 = attrs.length; k < len1; k++) {
            attr = attrs[k];
            if (attr.name === 'class') {
              if (!preMergedAttrs["class"]) {
                preMergedAttrs["class"] = [];
              }
              preMergedAttrs["class"].push(attr.val);
            } else {
              preMergedAttrs[attr.name] = attr.val;
            }
          }
          this.buf.push(", array(" + ((function() {
            var results;
            results = [];
            for (key in preMergedAttrs) {
              value = preMergedAttrs[key];
              results.push("'" + key + "' => " + (this.jsExpressionToPhp(key === 'class' ? "[" + value + "]" : value)));
            }
            return results;
          }).call(this)).join(', ') + ")");
        } else {
          if (phpArgs) {
            this.buf.push(", array()");
          }
        }
        if (phpArgs) {
          this.buf.push(", " + phpArgs);
        }
        this.buf.push(") ?>");
      } else {
        mixin_start = this.buf.length;
        mixinAttrs = ['$block = null', '$attributes = array()'];
        if (phpArgs) {
          ref = phpArgs.split(', ');
          for (l = 0, len2 = ref.length; l < len2; l++) {
            phpArg = ref[l];
            mixinAttrs.push(phpArg + " = null");
          }
        }
        this.buf.push("<?php if (!function_exists('mixin__" + phpMixinName + "')) { function mixin__" + phpMixinName + "(" + (mixinAttrs.join(', ')) + ") { ");
        if (rest) {
          this.buf.push((this.jsExpressionToPhp(rest)) + " = array_slice(func_get_args(), " + mixinAttrs.length + "); ");
        }
        if (phpArgs) {
          this.buf.push("global $■;");
          this.buf.push(((function() {
            var len3, n, ref1, results;
            ref1 = phpArgs.split(', ');
            results = [];
            for (n = 0, len3 = ref1.length; n < len3; n++) {
              phpArg = ref1[n];
              results.push("$■['" + (phpArg.replace('$', '')) + "'] = " + phpArg + ";");
            }
            return results;
          })()).join(''));
        }
        this.buf.push("?>");
        this.parentIndents++;
        oldInsideMixin = this.insideMixin;
        this.insideMixin = true;
        this.visit(block);
        this.insideMixin = oldInsideMixin;
        this.parentIndents--;
        this.buf.push("<?php } } ?>");
        mixin_end = this.buf.length;
        this.mixins[key].instances.push({
          start: mixin_start,
          end: mixin_end
        });
      }
    },

    /**
    Visit `tag` buffering tag markup, generating
    attributes, visiting the `tag`'s code and block.
    
    @param {Tag} tag
    @api public
     */
    visitTag: function(tag) {
      var bufferName, name, pp, self;
      bufferName = function() {
        if (tag.buffer) {
          self.bufferExpression(name);
        } else {
          self.buffer(name);
        }
      };
      this.indents++;
      name = tag.name;
      pp = this.pp;
      self = this;
      if ("pre" === tag.name) {
        this.escape = true;
      }
      if (!this.hasCompiledTag) {
        if (!this.hasCompiledDoctype && "html" === name) {
          this.visitDoctype();
        }
        this.hasCompiledTag = true;
      }
      if (pp && !tag.isInline()) {
        this.prettyIndent(0, true);
      }
      if (tag.selfClosing || (!this.xml && selfClosing.indexOf(tag.name) !== -1)) {
        this.buffer("<");
        bufferName();
        this.visitAttributes(tag.attrs, tag.attributeBlocks);
        if (this.terse) {
          this.buffer(">");
        } else {
          this.buffer("/>");
        }
        if (tag.block && !(tag.block.type === "Block" && tag.block.nodes.length === 0) && tag.block.nodes.some(function(tag) {
          return tag.type !== "Text" || !/^\s*$/.test(tag.val);
        })) {
          throw errorAtNode(tag, new Error(name + " is self closing and should not have content."));
        }
      } else {
        this.buffer("<");
        bufferName();
        this.visitAttributes(tag.attrs, tag.attributeBlocks);
        this.buffer(">");
        if (tag.code) {
          this.visitCode(tag.code);
        }
        this.visit(tag.block);
        if (pp && !tag.isInline() && "pre" !== tag.name && !tag.canInline()) {
          this.prettyIndent(0, true);
        }
        this.buffer("</");
        bufferName();
        this.buffer(">");
      }
      if ("pre" === tag.name) {
        this.escape = false;
      }
      this.indents--;
    },

    /**
    Visit `filter`, throwing when the filter does not exist.
    
    @param {Filter} filter
    @api public
     */
    visitFilter: function(filter) {
      var err, error1, text;
      text = filter.block.nodes.map(function(node) {
        return node.val;
      }).join("\n");
      filter.attrs.filename = this.options.filename;
      try {
        this.buffer(filters(filter.name, text, filter.attrs), true);
      } catch (error1) {
        err = error1;
        throw errorAtNode(filter, err);
      }
    },

    /**
    Visit `text` node.
    
    @param {Text} text
    @api public
     */
    visitText: function(text) {
      this.buffer(text.val, true);
    },

    /**
    Visit a `comment`, only buffering when the buffer flag is set.
    
    @param {Comment} comment
    @api public
     */
    visitComment: function(comment) {
      if (!comment.buffer) {
        return;
      }
      if (this.pp) {
        this.prettyIndent(1, true);
      }
      this.buffer("<!--" + comment.val + "-->");
    },

    /**
    Visit a `BlockComment`.
    
    @param {Comment} comment
    @api public
     */
    visitBlockComment: function(comment) {
      if (!comment.buffer) {
        return;
      }
      if (this.pp) {
        this.prettyIndent(1, true);
      }
      this.buffer("<!--" + comment.val);
      this.visit(comment.block);
      if (this.pp) {
        this.prettyIndent(1, true);
      }
      this.buffer("-->");
    },

    /**
    Visit `code`, respecting buffer / escape flags.
    If the code is followed by a block, wrap it in
    a self-calling function.
    
    @param {Code} code
    @api public
     */
    visitCode: function(code) {
      var condition, m, val;
      if (code.buffer) {
        val = code.val.trimLeft();
        val = this.jsExpressionToPhp(val);
        if (code.escape) {
          val = "htmlspecialchars(" + val + ")";
        }
        val = '<?php echo ' + val + ' ?>';
        this.bufferExpression(val);
      } else if (IF_REGEX.test(code.val)) {
        m = code.val.match(IF_REGEX);
        condition = m[1];
        this.visitIf({
          condition: condition,
          block: code.block,
          nextElses: this.nextElses
        });
      } else if (/^else/.test(code.val)) {

      } else if (LOOP_REGEX.test(code.val)) {
        this.visitLoop(code);
      } else {
        this.buf.push("<?php " + (this.jsExpressionToPhp(code.val)) + " ?>");
        if (code.block) {
          this.visit(code.block);
        }
      }
    },
    visitLoop: function(loopNode) {
      var conditions, loopType, m;
      m = loopNode.val.match(LOOP_REGEX);
      loopType = m[1];
      conditions = m[2];
      this.buf.push("<?php " + loopType + " (" + (this.jsExpressionToPhp(conditions)) + ") : ?>");
      if (loopNode.block) {
        this.visit(loopNode.block);
      }
      return this.buf.push("<?php end" + loopType + " ?>");
    },
    visitIf: function(ifNode) {
      var alternative, condition, k, len1, m, ref;
      this.buf.push("<?php if (" + (this.jsExpressionToPhp(ifNode.condition)) + ") : ?>");
      if (ifNode.block) {
        this.visit(ifNode.block);
      }
      if (!ifNode.nextElses) {
        return this.buf.push("<?php endif ?>");
      } else {
        ref = ifNode.nextElses;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          alternative = ref[k];
          if (alternative.val === "else") {
            this.buf.push("<?php else : ?>");
            this.visit(alternative.block);
          } else if (ELSE_IF_REGEX.test(alternative.val)) {
            m = alternative.val.match(ELSE_IF_REGEX);
            condition = m[1];
            this.buf.push("<?php elseif (" + (this.jsExpressionToPhp(condition)) + ") : ?>");
            this.visit(alternative.block);
          }
        }
        return this.buf.push("<?php endif ?>");
      }
    },

    /**
    Visit `each` block.
    
    @param {Each} each
    @api public
     */
    visitEach: function(each) {
      var as, scopePushPhp;
      as = each.key === '$index' ? this.jsExpressionToPhp(each.val) : (this.jsExpressionToPhp(each.key)) + " => " + (this.jsExpressionToPhp(each.val));
      scopePushPhp = "";
      if (each.key !== '$index') {
        scopePushPhp += "$■['" + each.key + "'] = " + (this.jsExpressionToPhp(each.key)) + ";";
      }
      scopePushPhp += "$■['" + each.val + "'] = " + (this.jsExpressionToPhp(each.val)) + ";";
      this.buf.push("<?php if (" + (this.jsExpressionToPhp(each.obj)) + ") : foreach (" + (this.jsExpressionToPhp(each.obj)) + " as " + as + ") : " + scopePushPhp + " ?>");
      this.visit(each.block);
      if (!each.alternative) {
        this.buf.push("<?php endforeach; endif ?>");
      } else {
        this.buf.push("<?php endforeach; else : ?>");
        this.visit(each.alternative);
        this.buf.push("<?php endif ?>");
      }
    },

    /**
    Visit `attrs`.
    
    @param {Array} attrs
    @api public
     */
    visitAttributes: function(attrs, attributeBlocks) {
      var attributeBlock, cc, val;
      if (attributeBlocks.length) {
        if (attrs.length) {
          val = this.attrs(attrs);
          attributeBlocks.unshift(val);
        }
        this.buffer("<?php attrs(" + ((function() {
          var k, len1, results;
          results = [];
          for (k = 0, len1 = attributeBlocks.length; k < len1; k++) {
            attributeBlock = attributeBlocks[k];
            if (attributeBlock[0] === '{') {
              cc = attributeBlock.replace(/jade\.escape/g, 'htmlspecialchars');
              results.push(this.jsExpressionToPhp(cc));
            } else {
              results.push(this.jsExpressionToPhp(attributeBlock));
            }
          }
          return results;
        }).call(this)).join(", ") + "); ?>");
      } else {
        if (attrs.length) {
          this.attrs(attrs, true);
        }
      }
    },

    /**
    Compile attributes.
     */
    attrs: function(attrs, buffer) {
      var attrClassArgs, buf, c, classEscaping, classes;
      buf = [];
      classes = [];
      classEscaping = [];
      attrs.forEach((function(attr) {
        var escaped, jadeString, jsString, key, val;
        key = attr.name;
        escaped = attr.escaped;
        if (key === "class") {
          classes.push(attr.val);
          classEscaping.push(attr.escaped);
        } else if (isConstant(attr.val)) {
          if (buffer) {
            this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
          } else {
            val = toConstant(attr.val);
            if (escaped && !(key.indexOf("data") === 0 && typeof val !== "string")) {
              val = runtime.escape(val);
            }
            buf.push(utils.stringify(key) + ": " + utils.stringify(val));
          }
        } else {
          if (buffer) {
            if (/^[a-zA-Z_][a-z_A-Z0-9]*/.test(attr.val)) {
              this.bufferExpression("<?php attr('" + key + "', " + (this.jsExpressionToPhp(attr.val)) + ", " + (escaped ? 'true' : 'false') + ") ?>");
            } else {
              jsString = attr.val;
              jadeString = jsString.replace(/^"/, '').replace(/"$/, '');
              jadeString = jadeString.replace(/"\s\+\s\(([^"]+)\)\s\+\s"/g, '#{$1}');
              this.buffer(" " + key + "=\"");
              this.buffer(jadeString, true);
              this.buffer("\"");
            }
          } else {
            val = attr.val;
            if (escaped && (key.indexOf("data") !== 0)) {
              val = "jade.escape(" + val + ")";
            } else {
              if (escaped) {
                val = "(typeof (jade_interp = " + val + ") == \"string\" ? jade.escape(jade_interp) : jade_interp)";
              }
            }
            buf.push(utils.stringify(key) + ": " + val);
          }
        }
      }).bind(this));
      if (buffer) {
        if (classes.every(isConstant)) {
          this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
        } else {
          attrClassArgs = classes.length === 1 ? this.jsExpressionToPhp(classes[0]) : ((function() {
            var k, len1, results;
            results = [];
            for (k = 0, len1 = classes.length; k < len1; k++) {
              c = classes[k];
              results.push(this.jsExpressionToPhp(c));
            }
            return results;
          }).call(this)).join(', ');
          this.buffer("<?php attr_class(" + attrClassArgs + ") ?>");
        }
      } else if (classes.length) {
        if (classes.every(isConstant)) {
          classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function(cls, i) {
            if (classEscaping[i]) {
              return runtime.escape(cls);
            } else {
              return cls;
            }
          })));
        } else {
          classes = "(jade_interp = " + utils.stringify(classEscaping) + "," + " jade.joinClasses([" + classes.join(",") + "].map(jade.joinClasses).map(function (cls, i) {" + "   return jade_interp[i] ? jade.escape(cls) : cls" + " }))" + ")";
        }
        if (classes.length) {
          buf.push("\"class\": " + classes);
        }
      }
      return "{" + buf.join(",") + "}";
    }
  };

}).call(this);
