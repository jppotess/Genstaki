// Generated by CoffeeScript 1.10.0
(function() {
  var JadePhpCompiler, basename, dirname, exists, files, fs, getNameFromFileName, jade, join, mkdirp, monocle, options, path, program, renderFile, resolve, stdin, transpileJadeToPhp;

  fs = require('fs');

  path = require('path');

  basename = path.basename;

  dirname = path.dirname;

  resolve = path.resolve;

  exists = fs.existsSync || path.existsSync;

  join = path.join;

  program = require('commander');

  monocle = require('monocle')();

  mkdirp = require('mkdirp');

  jade = require('jade');

  JadePhpCompiler = require('./JadePhpCompiler');

  options = {};

  program.version(require('../package.json').version).usage('[options] [dir|file ...]').option('--omit-php-runtime', 'don\'t include php runtime into compiled templates').option('--omit-php-extractor', 'don\'t include php extractor code into compiled templates').option('-O, --obj <str>', 'javascript options object').option('-o, --out <dir>', 'output the compiled html to <dir>').option('-p, --path <path>', 'filename used to resolve includes').option('-P, --pretty', 'compile pretty html output').option('-c, --client', 'compile function for client-side runtime.js').option('-n, --name <str>', 'The name of the compiled template (requires --client)').option('-D, --no-debug', 'compile without debugging (smaller functions)').option('-w, --watch', 'watch files for changes and automatically re-render').option('--name-after-file', 'Name the template after the last section of the file path (requires --client and overriden by --name)').option('--doctype <str>', 'Specify the doctype on the command line (useful if it is not specified by the template)').option('--arrays-only', 'convert $a->b to $a["b"] (default behavior)').option('--no-arrays-only', 'don\'t convert $a->b to $a["b"]');

  program.on('--help', function() {
    return console.log("Examples:\n\n	# translate jade the templates dir\n	$ jade templates\n\n	# create {foo,bar}.html\n	$ jade {foo,bar}.jade\n\n	# jade over stdio\n	$ jade < my.jade > my.html\n\n	# jade over stdio\n	$ echo 'h1 Jade!' | jade\n\n	# foo, bar dirs rendering to /tmp\n	$ jade foo bar --out /tmp");
  });

  program.parse(process.argv);

  if (program.obj) {
    options = exists(program.obj) ? JSON.parse(fs.readFileSync(program.obj)) : eval('(' + program.obj + ')');
  }

  if (program.omitPhpRuntime) {
    options.omitPhpRuntime = true;
  }

  if (program.omitPhpExtractor) {
    options.omitPhpExtractor = true;
  }

  options.arraysOnly = program.arraysOnly;

  if (program.path) {
    options.filename = program.path;
  }

  options.watch = program.watch;

  files = program.args;

  transpileJadeToPhp = function(str, options) {
    var compiler, parser, tokens;
    if (options == null) {
      options = {
        filename: ''
      };
    }
    parser = new jade.Parser(str, options.filename, options);
    tokens = parser.parse();
    compiler = new JadePhpCompiler(tokens, options);
    return compiler.compile();
  };

  stdin = function() {
    var buf;
    buf = "";
    process.stdin.setEncoding("utf8");
    process.stdin.on("data", function(chunk) {
      return buf += chunk;
    });
    process.stdin.on("end", function() {
      var output;
      output = transpileJadeToPhp(buf, options);
      return process.stdout.write(output);
    });
    process.stdin.resume();
    return process.on("SIGINT", function() {
      process.stdout.write("\n");
      process.stdin.emit("end");
      process.stdout.write("\n");
      return process.exit();
    });
  };

  getNameFromFileName = function(filename) {
    var file;
    file = path.basename(filename, ".jade");
    return file.toLowerCase().replace(/[^a-z0-9]+([a-z])/g, function(_, character) {
      return character.toUpperCase();
    }) + "Template";
  };

  renderFile = function(path) {
    var re;
    re = /\.jade$/;
    return fs.lstat(path, function(err, stat) {
      if (err) {
        throw err;
      }
      if (stat.isFile() && re.test(path)) {
        return fs.readFile(path, "utf8", function(err, str) {
          var compiledPhp, dir, extname;
          if (err) {
            throw err;
          }
          options.filename = path;
          if (program.nameAfterFile) {
            options.name = getNameFromFileName(path);
          }
          console.log("transpiling " + path);
          compiledPhp = transpileJadeToPhp(str, options);
          extname = ".php";
          path = path.replace(re, extname);
          if (program.out) {
            path = join(program.out, basename(path));
          }
          dir = resolve(dirname(path));
          return mkdirp(dir, 0x1ed, function(err) {
            var e, error;
            if (err) {
              throw err;
            }
            try {
              return fs.writeFile(path, compiledPhp, function(err) {
                if (err) {
                  throw err;
                }
                return console.log("  \u001b[90mrendered \u001b[36m%s\u001b[0m", path);
              });
            } catch (error) {
              e = error;
              if (options.watch) {
                return console.error(e.stack || e.message || e);
              } else {
                throw e;
              }
            }
          });
        });
      } else if (stat.isDirectory()) {
        return fs.readdir(path, function(err, files) {
          if (err) {
            throw err;
          }
          return files.map(function(filename) {
            return path + "/" + filename;
          }).forEach(renderFile);
        });
      }
    });
  };

  if (files.length) {
    console.log();
    if (options.watch) {
      process.on("uncaughtException", function(err) {
        return console.error(err);
      });
      files.forEach(renderFile);
      monocle.watchFiles({
        files: files,
        listener: function(file) {
          return renderFile(file.absolutePath);
        }
      });
    } else {
      files.forEach(renderFile);
    }
    process.on("exit", function() {
      return console.log();
    });
  } else {
    stdin();
  }

}).call(this);
